/*
 * 		Copyright (c) 2007-2009 POK team
 *
 *		Redistribution and use in source and binary forms, with or without
 *		modification, are permitted provided that the following conditions
 *		are met:
 *
 *			* Redistributions of source code must retain the above copyright
 *			  notice, this list of conditions and the following disclaimer.
 *			* Redistributions in binary form must reproduce the above
 *			  copyright notice, this list of conditions and the following
 *			  disclaimer in the documentation and/or other materials
 *			  provided with the distribution.
 *			* Neither the name of the POK Team nor the names of its main
 *			  author (Julien Delange) or its contributors may be used to
 *			  endorse or promote products derived from this software
 *			  without specific prior written permission.
 *
 *		THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *		AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *		LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *		FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *		COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 *		INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *		BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 *		LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 *		CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 *		LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 *		ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 *		POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * \file loader.c
 *
 * Contains all needed stuff to load partitions (elf files).
 * This needs the partitioning service (POK_NEEDS_PARTITIONS must
 * be defined) to work.
 */


#ifdef POK_NEEDS_PARTITIONS

#include <errno.h>
#ifndef POK_ARCH_PATMOS
#include <elf.h>
#include <libc.h>
#else
#ifdef POK_NEEDS_DEBUG
#include <stdio.h>
#endif
#include <machine/uart.h>
#include <string.h>
#endif
#include <core/error.h>
#include <core/partition.h>
#include <core/debug.h>


#ifndef POK_LOADER_BLOCK_SIZE
#define POK_LOADER_BLOCK_SIZE 64*1024
#endif

#ifndef POK_ARCH_PATMOS
/**
 * part_sizes is automatically generated by the build process and contains the
 * size of the elf file of the partitions.
 */
extern uint32_t part_sizes[];

/**
 * Load an ELF file.
 * \warning Shoud be not used alone, called by pok_loader_load_partition
 */
static pok_ret_t pok_loader_elf_load	(char* file,
					uint32_t offset,
					void** entry)
{
	Elf32_Ehdr*  elf_header;
	Elf32_Phdr*  elf_phdr;
#ifndef POK_SKIP_LOADER
	unsigned int 	i;
	/* Added */
	unsigned int 	j, nb_blocks;
	char*		dest;
#else
	(void) offset;
#endif
	elf_header = (Elf32_Ehdr*)file;

	if (elf_header->e_ident[0] != 0x7f ||
		 elf_header->e_ident[1] != 'E' ||
		 elf_header->e_ident[2] != 'L' ||
		 elf_header->e_ident[3] != 'F')
	{
		return POK_ERRNO_NOTFOUND;
	}

	/* Sets the entry point virtual address */
	*entry = (void*)elf_header->e_entry;

	elf_phdr = (Elf32_Phdr*)(file + elf_header->e_phoff);

#ifndef POK_SKIP_LOADER
	for (i = 0; i < elf_header->e_phnum; ++i)
	{
		dest = (char *)elf_phdr[i].p_vaddr + offset;

 #ifdef POK_NEEDS_DEBUG
		printf("Loading partition code from %s to %s, for a size of : %u \n", elf_phdr[i].p_offset + file, dest, elf_phdr[i].p_filesz );
 #endif
		nb_blocks = elf_phdr[i].p_filesz / (POK_LOADER_BLOCK_SIZE);
		for (j = 0; j < nb_blocks; j++ )
		{
			memcpy (dest+(j*POK_LOADER_BLOCK_SIZE) , elf_phdr[i].p_offset + file + (j*POK_LOADER_BLOCK_SIZE) , POK_LOADER_BLOCK_SIZE );
#ifdef POK_NEEDS_DEBUG
			printf ("Copied block %d/%d, from %s to %s for a size of %x \n", j+1,nb_blocks, elf_phdr[i].p_offset + file + (j*POK_LOADER_BLOCK_SIZE),dest+(j*POK_LOADER_BLOCK_SIZE),POK_LOADER_BLOCK_SIZE  );
#endif
		}
		memcpy (dest+(j*POK_LOADER_BLOCK_SIZE), elf_phdr[i].p_offset + file + (j*POK_LOADER_BLOCK_SIZE) , elf_phdr[i].p_filesz-(j*POK_LOADER_BLOCK_SIZE ));
#ifdef POK_NEEDS_DEBUG
	 	printf ("Copied last partial block from %s to %s ( size = %x ) \n",elf_phdr[i].p_offset + file + (j*POK_LOADER_BLOCK_SIZE),dest+(j*POK_LOADER_BLOCK_SIZE),elf_phdr[i].p_filesz-(j*POK_LOADER_BLOCK_SIZE )  );
#endif
 
#ifndef POK_DISABLE_LOADER_DATA_INIT	 
#ifdef POK_NEEDS_DEBUG
		printf("Razing partition data from %s for a size of : %x \n",dest + elf_phdr[i].p_filesz+(j*POK_LOADER_BLOCK_SIZE)  ,elf_phdr[i].p_memsz - elf_phdr[i].p_filesz );	
#endif
		nb_blocks = (elf_phdr[i].p_memsz - elf_phdr[i].p_filesz)/ (POK_LOADER_BLOCK_SIZE);
		for (j = 0; j < nb_blocks; j++ ) 
		{
	  		memset (dest + elf_phdr[i].p_filesz+(j*POK_LOADER_BLOCK_SIZE) , 0, POK_LOADER_BLOCK_SIZE);
#ifdef POK_NEEDS_DEBUG
			printf ("Razed block %d/%d, from %x to %x for a size of %x \n", j+1,nb_blocks, elf_phdr[i].p_offset + file + (j*POK_LOADER_BLOCK_SIZE),dest+(j*POK_LOADER_BLOCK_SIZE),POK_LOADER_BLOCK_SIZE	);
#endif
		}
		 
		memset (dest + elf_phdr[i].p_filesz+(j*POK_LOADER_BLOCK_SIZE) , 0, (elf_phdr[i].p_memsz - elf_phdr[i].p_filesz)-(j*POK_LOADER_BLOCK_SIZE));
#ifdef
		printf ("Razed last block  from %x for a size of %x \n", dest + elf_phdr[i].p_filesz + (j*POK_LOADER_BLOCK_SIZE), (elf_phdr[i].p_memsz - elf_phdr[i].p_filesz)- (j*POK_LOADER_BLOCK_SIZE));
#endif
#endif 
	}
#endif /* ! POK_SKIP_LOADER */
	return POK_ERRNO_OK;
}


void pok_loader_load_partition (const uint8_t part_id,
								uint32_t offset,
								uint32_t *entry)
{
	void*		elf_entry = POK_NULL;
	extern char __archive2_begin;
	uint32_t	size;
	uint16_t	t;

	size = 0;
	t	 = 0;

	while (t < part_id)
	{
		size += part_sizes[t];
		t++;
	}

	if (pok_partitions[part_id].size < part_sizes[part_id])
	{
#ifdef POK_NEEDS_ERROR_HANDLING
		pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
#else
 #ifdef POK_NEEDS_DEBUG
		/* We consider that even if errors are not raised, we must print an error
		 * for such error
		 * So, when we are using the debug mode, we print a fatal error.
		 */
#include <core/debug.h>
#include <stdio.h>
		printf("Declared size for partition %d : %d\n", part_id, pok_partitions[part_id].size);
		printf("Real size for partition %d	  : %d\n", part_id, part_sizes[part_id]);
		pok_fatal ("Partition size is not correct\n");
 #endif
#endif
	}
	pok_loader_elf_load ((&__archive2_begin) + size , offset, &elf_entry);
	*entry = (uint32_t)elf_entry;
}
#endif

#ifdef POK_ARCH_PATMOS

static uint32_t read_uint32(uint32_t* ptr)
{
  return uart_read((char*)(ptr), sizeof(uint32_t));
}

static uint32_t read_data(uint32_t size, char* ptr)
{
  return uart_read(ptr, size);
}

void pok_loader_load_partition (const uint32_t part_id, uint32_t *entry)
{
	(void) part_id;
	uint32_t part_entry;
    uint32_t segments;
    if(read_uint32(&part_entry) != sizeof(uint32_t))
    {
#ifdef POK_NEEDS_ERROR_HANDLING
		pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
#else
#ifdef POK_NEEDS_DEBUG
#include <core/debug.h>
#include <stdio.h>
		pok_fatal ("No partition entry\n");
#endif
#endif
    }

    if(read_uint32(&segments) != sizeof(uint32_t))
    {
#ifdef POK_NEEDS_ERROR_HANDLING
		pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
#else
#ifdef POK_NEEDS_DEBUG
#include <core/debug.h>
#include <stdio.h>
		pok_fatal ("No partition size\n");
#endif
#endif
    }

#ifdef POK_NEEDS_DEBUG
    printf("[DEBUG]\t [Reading partition %d] Entry address: %p\n", part_id, (void*)(part_entry));
    printf("[DEBUG]\t [Reading partition %d] Segments number: %d\n", part_id, segments);
#endif

    unsigned int segment = 0;
    unsigned int part_size = 0;
    while (segment < segments) 
    {
	    uint32_t segment_address;
	    uint32_t segment_size;

     	if (read_uint32(&segment_address) != sizeof(uint32_t))
     	{
#ifdef POK_NEEDS_ERROR_HANDLING
			pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
#else
#ifdef POK_NEEDS_DEBUG
#include <core/debug.h>
#include <stdio.h>
			pok_fatal ("No segment address\n");
#endif
#endif
      	}

#ifdef POK_NEEDS_DEBUG
      	printf("[DEBUG]\t [Reading partition %d] Segment %d address: %p\n", part_id, segment, (void*)segment_address);
#endif

      	if (read_uint32(&segment_size) != sizeof(uint32_t))
      	{
#ifdef POK_NEEDS_ERROR_HANDLING
			pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
#else
#ifdef POK_NEEDS_DEBUG
#include <core/debug.h>
#include <stdio.h>
			pok_fatal ("No segment size\n");
#endif
#endif
      	}
#ifdef POK_NEEDS_DEBUG
      	printf("[DEBUG]\t [Reading partition %d] Segment %d size: %d\n", part_id, segment, segment_size);
#endif

      	if (read_data(segment_size, (char*)(segment_address)) != segment_size) {
#ifdef POK_NEEDS_ERROR_HANDLING
			pok_partition_error (part_id, POK_ERROR_KIND_PARTITION_CONFIGURATION);
#else
#ifdef POK_NEEDS_DEBUG
#include <core/debug.h>
#include <stdio.h>
			printf("No segment data\n");
#endif
#endif
      	}
        part_size = part_size + segment_size;

#ifdef POK_NEEDS_DEBUG
      	printf("[DEBUG]\t [Reading partition %d] Segment %d loaded\n", part_id, segment);
#endif

      	segment++;
    }

    *entry = (uint32_t) (part_entry);
}

#endif


#endif /* POK_NEEDS_PARTITIONS */
